// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Bunny {
    float4 pos;
    float2 vel;
    float pad0;
    float pad1;
};

RWStructuredBuffer<Bunny> bunnies;
float xBound;
float yBound;
float gravity;

float3 hash32(float2 p)
{
	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return frac((p3.xxy+p3.yzz)*p3.zyx);
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    Bunny bunny = bunnies[id.x];

    // Generate 3 random numbers from the x and y coords of the bunny
    float3 rands = hash32(bunny.pos.xy);

    bunny.pos.x += bunny.vel.x;
    bunny.pos.y += bunny.vel.y;
    bunny.vel.y -= gravity;

    if (bunny.pos.x > xBound) {
        bunny.vel.x *= -1;
        bunny.pos.x = xBound;
    } else if (bunny.pos.x < -xBound) {
        bunny.vel.x *= -1;
        bunny.pos.x = -xBound;
    }

    if (bunny.pos.y < -yBound) {
        bunny.vel.y *= -0.85f;
        bunny.pos.y = -yBound;
        bunny.pos.w = rands.x * 0.2f - 0.1f; // Passing rotation through w value of position
        if (rands.y > 0.5f) {
            bunny.vel.y += rands.z * 0.1f;
        }
    } else if (bunny.pos.y > yBound) {
        bunny.vel.y = 0;
        bunny.pos.y = yBound;
    }

    bunnies[id.x] = bunny;
}
